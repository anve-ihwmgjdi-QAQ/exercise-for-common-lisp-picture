(defun make-left->right-array (function high width)
  (let ((arr (make-array (list high width)))
	(arr-high (- high 1))
	(arr-width (- width 1)))
    (declare (type function function)
	     (type fixnum high width arr-high arr-width))
    (labels ((iter (h w)
	       (declare (type fixnum h w))
	       (cond ((> h arr-high) arr)
		     ((>= w arr-width)
		      (progn (setf (aref arr h w) (the fixnum (funcall function)))
			     (iter (the fixnum (+ h 1)) 0)))
		     (t (progn (setf (aref arr h w) (the fixnum (funcall function)))
			       (iter h (the fixnum (+ w 1))))))))
      (iter 0 0))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;list 'used-high or 'used-width code;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;high  (up . down)
;;width (left . right)

;(defun make-used-seq (up-or-left down-or-right)
;  (cons up-or-left down-or-right))
;(defun used-up (used-seq) (car used-seq))
;(defun used-down (used-seq) (cdr used-seq))
;(defun used-left (used-seq) (car used-seq))
;(defun used-right (used-seq) (cdr used-seq))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun make-used-seq (up-or-left down-or-right)
  (declare (type fixnum up-or-left down-or-right))
  (vector up-or-left down-or-right))
(defun used-up (used-seq)
  (declare (type vector used-seq))
  (svref used-seq 0))
(defun used-down (used-seq)
  (declare (type vector used-seq))
  (svref used-seq 1))
(defun used-left (used-seq)
  (declare (type vector used-seq))
  (svref used-seq 0))
(defun used-right (used-seq)
  (declare (type vector used-seq))
  (svref used-seq 1))


(defun next-aref (high width direction used-high used-width times)
  (declare (type fixnum high width times)
	   (type symbol direction)
	   ;(type list used-high used-width))
	   (type vector used-high used-width))
  (cond ((>= times 10) nil)
	((eq direction 'right)
	 (let ((should-move (+ width 1)))
	   (if (> should-move (used-right used-width))
	       (next-aref high width 'down (make-used-seq  (1+ (used-up used-high))
							   (used-down used-high))
						 
			  used-width (1+ times))
	       (values high should-move 'right used-high used-width))))
	((eq direction 'down)
	 (let ((should-move (+ high 1)))
	   (if (> should-move (used-down used-high))
	       (next-aref high width 'left used-high
			  (make-used-seq (used-left used-width)
					 (1- (used-right used-width)))
			  (1+ times))
	       (values should-move width 'down used-high used-width))))
	((eq direction 'left)
	 (let ((should-move (- width 1)))
	   (if (< should-move (used-left used-width))
	       (next-aref high width 'up (make-used-seq (used-up used-high)
					       (1- (used-down used-high)))
			  used-width (1+ times))
	       (values high should-move 'left used-high used-width))))
	((eq direction 'up)
	 (let ((should-move (- high 1)))
	   (if (< should-move (used-up used-high))
	       (next-aref high width 'right used-high
			  (make-used-seq (1+ (used-left used-width))
				(used-right used-width))
			  (1+ times))
	       (values should-move width 'up used-high used-width))))))

(defun make-loop-arr (function high width)
  (let ((arr (make-array (list high width)))
	(arr-high (1- high))
	(arr-width (1- width)))
    (labels ((iter (h w r u-h u-w)
	       (multiple-value-bind (next-h next-w next-r next-u-h next-u-w)
		   (next-aref h w r u-h u-w 0)
		 (if (null next-h)
		     (progn (setf (aref arr h w) (funcall function))
			    arr)
		     (progn (setf (aref arr h w) (funcall function))
			    (iter next-h next-w next-r next-u-h next-u-w))))))
      (iter 0 0 'right (make-used-seq 0 arr-high) (make-used-seq 0 arr-width)))))


